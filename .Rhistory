deaths <- deaths_by_year_side[, .(          # Aggregate by year and hot/cold
total_deaths = mean(total_deaths, na.rm = TRUE),  # Average across years
deaths_q025 = mean(deaths_q025, na.rm = TRUE),
deaths = mean(deaths, na.rm = TRUE),
deaths_q975 = mean(deaths_q975, na.rm = TRUE)
), by = .(side)][, key := as.character(decade_key)][, model := model_name]
list(response = response, deaths = deaths, deaths_by_year_side = deaths_by_year_side)
})
# Combine results from all decades
out <- list(
response = rbindlist(lapply(decade_results, `[[`, "response")),
deaths = rbindlist(lapply(decade_results, `[[`, "deaths")),
deaths_by_year_side = rbindlist(lapply(decade_results, `[[`, "deaths_by_year_side"))
)
# Decade attributable deaths if response function was fixed at 1970
# with decade specific mmt
if (country_name == "US" & !log_rate) {
pop_var <- "pop_all"              # Default: All populations
death_var <- "n_deaths_all"
decade_fixed1970 <- lapply(decades, function(decade_key) {
fixed_decade <- 1970
print(paste("Processing decade:", decade_key))
current_mort <- mort[decade == decade_key]
if (country_name == "EU") {
time_agg_var <- "week"
adm_year_pop_death <- current_mort[, .(adm_id, year, week, pop = get(pop_var), n_deaths = get(death_var))]
} else {
time_agg_var <- "month"
adm_year_pop_death <- current_mort[, .(adm_id, year, month, pop = get(pop_var), n_deaths = get(death_var))]
}
current_narrow_panel <- daily_temp[decade == decade_key]
current_observed_temp <- current_narrow_panel$temp1
decade_cols <- names(coefs)[grepl("temp", names(coefs)) & grepl(as.character(decade_key), names(coefs))]
coefs_before_sum <- t(as.matrix(coefs[decade_cols]))
# Cumulative effect of lags and keep matrix format
poly_groups <- c("temp_d1", "temp_d2", "temp_d3", "temp_d4")
coefs_sum <- sapply(poly_groups, function(poly) {
poly_names <- colnames(coefs_before_sum)[grepl(poly, colnames(coefs_before_sum)) & !grepl("prec", colnames(coefs_before_sum))]
rowSums(coefs_before_sum[, poly_names, drop = FALSE])
})
coefs_sum <- t(as.matrix(coefs_sum))
pred_vector <- pred_temps_poly %*% t(coefs_sum)
# Crop predictions by 1% and 99% percentile of observed temp distribution
t1_index <- quantile(current_observed_temp, 0.01, na.rm = TRUE)
t99_index <- quantile(current_observed_temp, 0.998, na.rm = TRUE)
mmt_options <- which(pred_temp_range > t1_index & pred_temp_range < t99_index)
new_temp_range <- pred_temp_range[mmt_options]
mmt <- new_temp_range[which.min(pred_vector[mmt_options])]
mmt_matrix <- poly(mmt, degree = 4, raw = TRUE)
pred_temps_scaled <- scale(pred_temps_poly, center = mmt_matrix, scale = FALSE)
# Bootstrap coefficients
temp_cols <- names(bstrap)[grepl("temp", names(bstrap)) & grepl(as.character(fixed_decade), names(bstrap))]
bst_coefs_before_sum <- bstrap[, ..temp_cols]
bst_coefs_before_sum <- as.matrix(bst_coefs_before_sum)
# Sum coefficients by poly group (vectorized)
poly_groups <- c("temp_d1", "temp_d2", "temp_d3", "temp_d4")
bst_coefs_sum <- sapply(poly_groups, function(poly) {
poly_names = colnames(bst_coefs_before_sum)[grepl(poly, colnames(bst_coefs_before_sum)) & !grepl("prec", colnames(bst_coefs_before_sum))]
rowSums(bst_coefs_before_sum[, poly_names, drop = FALSE])
})
bstrap_result <- pred_temps_scaled %*% t(bst_coefs_sum)
# Calculate response statistics (vectorized)
response_stats <- cbind(
matrixStats::rowQuantiles(bstrap_result, probs = c(0.025, 0.5, 0.975), na.rm = TRUE),
mean = matrixStats::rowMeans2(bstrap_result, na.rm = TRUE)
)
response <- data.table(
pred_q025 = response_stats[, 1],
pred = response_stats[, 4],  # Using mean
pred_q975 = response_stats[, 3],
bins = pred_temp_range
)[, `:=` (
key = as.character(decade_key),
model = model_name,
t1 = t1_index,
t99 = t99_index
)]
# --- 9. Add annual average person days exposure
midpoints <- (pred_temp_range[-1] + pred_temp_range[-length(pred_temp_range)]) / 2
midpoints <- as.character(midpoints)
cols <- c("adm_id", "year", time_agg_var, pop_var)
pwd <- merge( current_mort[, ..cols], temp_bins, by = c("adm_id", "year", time_agg_var) )
setnames(pwd, pop_var, "pop")
pwd <- pwd[!is.na(pop)]
pwd[, (midpoints) := lapply(.SD, function(x) x * pop), .SDcols = midpoints]
pwd <- pwd[, lapply(.SD, sum), .SDcols = midpoints, by = .(year)]
annual_pwd <- pwd[, lapply(.SD, mean), .SDcols = midpoints]
annual_pwd <- melt(annual_pwd, measure.vars = midpoints, variable.name = "bins", value.name = "pop_deg_days", na.rm = TRUE)
annual_pwd[, bins := ceiling(as.numeric(as.character(bins)))]
response <- merge(response, annual_pwd, by = "bins", all.x = T)
rm(pwd, annual_pwd)
gc()
# create side indicator in relation to mmt
current_narrow_panel[, side := fifelse(temp1 > mmt, "hot", "cold")]
# --- 12. Prepare aggregated panel ---
current_narrow_panel <- current_narrow_panel[!is.na(side), .(
temp1 = sum(temp1),
temp2 = sum(temp2),
temp3 = sum(temp3),
temp4 = sum(temp4),
ndays = .N
), by = c("adm_id", "year", time_agg_var, "side")]
# --- 12. Merge Population/Death Data ---
current_narrow_panel <- merge(current_narrow_panel, adm_year_pop_death, by = c("adm_id", "year", time_agg_var))
# --- 13. Death Prediction via Bootstrap ---
temp_cols <- paste0("temp", 1:4)
pred_mat <- as.matrix(current_narrow_panel[, ..temp_cols])
pred_mat <- pred_mat - matrix(current_narrow_panel$ndays %o% t(mmt_matrix), ncol = 4)  # Scale by days
bstrap_deaths <- pred_mat %*% t(bst_coefs_sum)
# --- 14. Number of estimated deaths ---
if (log_rate == TRUE) {
# transform back to level
typical_rate <- mean(current_mort %>% pull(outcome_var), na.rm = TRUE)
bstrap_deaths <- sweep(expm1(bstrap_deaths), 1, current_narrow_panel$pop, "*") * typical_rate
} else (
bstrap_deaths <- sweep(bstrap_deaths, 1, current_narrow_panel$pop, "*")
)
bstrap_deaths <- as.data.table(bstrap_deaths)
colnames(bstrap_deaths) <- paste0("b", 1:100)
current_narrow_panel <- cbind(current_narrow_panel, bstrap_deaths)
# aggregate annual deaths
annual_total_deaths <- adm_year_pop_death[, .(total_deaths = sum(n_deaths, na.rm = TRUE)), by = .(year)]
# deaths by year and side
deaths_by_year_side <- current_narrow_panel %>%
group_by(year, side) %>%
summarise(across(starts_with("b"), ~sum(.x, na.rm = T))) %>%
ungroup() %>% group_by(year, side) %>%
summarise(
deaths = mean(c_across(starts_with("b")), na.rm = TRUE),
deaths_q025 = quantile(c_across(starts_with("b")), 0.025, na.rm = TRUE),
deaths_q975 = quantile(c_across(starts_with("b")), 0.975, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(key = as.character(decade_key), model = model_name) %>% left_join(annual_total_deaths) %>% as.data.table()
# deaths by side
deaths <- deaths_by_year_side[, .(          # Aggregate by year and hot/cold
total_deaths = mean(total_deaths, na.rm = TRUE),  # Average across years
deaths_q025 = mean(deaths_q025, na.rm = TRUE),
deaths = mean(deaths, na.rm = TRUE),
deaths_q975 = mean(deaths_q975, na.rm = TRUE)
), by = .(side)][, key := as.character(decade_key)][, model := model_name]
list(response = response, deaths = deaths, deaths_by_year_side = deaths_by_year_side)
})
decade_fixed1970_out <- list(
response = rbindlist(lapply(decade_fixed1970, `[[`, "response")),
deaths = rbindlist(lapply(decade_fixed1970, `[[`, "deaths")),
deaths_by_year_side = rbindlist(lapply(decade_fixed1970, `[[`, "deaths_by_year_side"))
)
decade_fixed1970_out_file <- file.path(processed_country_dir, paste0(country_name, "_", model_name, "_fixed1970_results.rds"))
saveRDS(decade_fixed1970_out, decade_fixed1970_out_file)
}
}
# Save output for each model
output_file <- file.path(processed_country_dir, paste0(country_name, "_", model_name, "_results.rds"))
message("Saving results to: ", output_file)
saveRDS(out, output_file)
}
################################################################################
# END OF SCRIPT
################################################################################
MEX_Pooled_results <- readRDS("~/BurkeLab Dropbox/projects/temperature-mortality/processed/MEX/MEX_Pooled_results.rds")
MEX_Pooled_results
MEX_Pooled_results$response_by_year_bins %>%
mutate(deaths = (pred*pop_deg_days)/total_deaths) %>% group_by(bins) %>%
summarise(deaths = mean(deaths, na.rm = T)) %>% as.data.table() %>%
ggplot(aes(x = bins, y = deaths)) +
geom_bar(stat = 'identity', position = 'stack', width = 1, alpha = 1) +
scale_y_continuous(
labels = scales::percent_format()
)
bstrap_result
annual_pwd_bins
model_name
model_name <- "Pooled"
# model_name <- "Pooled"
message("Processing model: ", model_name)
# Set analysis parameters
Nboot <- 100
formula <- model_formula_list[[model_name]]
weights <- NULL
override <- F
out_dir <- file.path(processed_country_dir, paste0(country_name, "_BootstrapResult_", tolower(model_name), "_n", Nboot, ".rds"))
if (!override & file.exists(out_dir)){
message("Loading existing bootstrap results from: ", out_dir)
bstrap <- readRDS(out_dir)
} else {
options(warn = -1)
set.seed(12)
setkey(mort, adm_id)
unique_ids <- unique(mort$adm_id)
n_units <- length(unique_ids)
results <- lapply(1:Nboot, function(i) {
message("Bootstrapping: ", i)
# Resample spatial units with replacement
sampled_units <- unique_ids[sample.int(n_units, n_units, replace = TRUE)]
dtboot <- mort[.(sampled_units), allow.cartesian = TRUE]
# dtboot <- mort[adm_id %in% sampled_units]
if (is.null(weights)) {
if (log_rate == TRUE) {
message("Running quasipoisson model ...")
fit <- fixest::feglm(formula, family = "quasipoisson", data = dtboot, nthreads = 6)
} else {
fit <- fixest::feols(formula, data = dtboot, nthreads = 6)
}
} else {
if (log_rate == TRUE) {
message("Running quasipoisson model ...")
fit <- fixest::feglm(formula, family = "quasipoisson" , data = dtboot, weights = dtboot[[weights]], nthreads = 6)
} else {
fit <- fixest::feols(formula, data = dtboot, weights = dtboot[[weights]], nthreads = 6)
}
}
model_results <- coef(fit)
model_results <- as.data.table(t(model_results), stringsAsFactors = FALSE)
model_results$iteration <- i
return(model_results)
})
bstrap <- do.call(rbind, results)
out_dir <- file.path(processed_country_dir, paste0(country_name, "_BootstrapResult_", tolower(model_name), "_n", Nboot, ".rds"))
message("Saving bootstrap results to: ", out_dir)
write_rds(bstrap, out_dir)
}
############################################################################
# SECTION 2: MODEL ESTIMATION
############################################################################
setkey(mort, adm_id)
setDT(bstrap)
if (log_rate == TRUE) {
coefs <- feglm(formula, family = "quasipoisson", data = mort, weights = NULL, only.coef = TRUE)
} else {
coefs <- feols(formula, data = mort, weights = NULL, only.coef = TRUE)
}
# Set analysis parameters
# pwd <- mapping_pooled_pwd[[model_name]]
coef_pattern <- "temp"
pred_temp_range <- -50:50
pred_temps_poly <- poly(pred_temp_range, degree = 4, raw = TRUE)
# --- 0. Population-Specific Variables ---
# Assign population and death columns based on model_name
if (model_name == "Young") {
pop_var <- "pop_young"
death_var <- "n_deaths_young"
outcome_var <- "rate_young"
} else if (model_name == "Adult") {
pop_var <- "pop_adult"
death_var <- "n_deaths_adult"
outcome_var <- "rate_adult"
} else if (model_name == "Elderly") {
pop_var <- "pop_elderly"
death_var <- "n_deaths_elderly"
outcome_var <- "rate_elderly"
} else {
pop_var <- "pop_all"              # Default: All populations
death_var <- "n_deaths_all"
outcome_var <- "rate_all"
}
if (country_name == "EU") {
time_agg_var <- "week"
} else {
time_agg_var <- "month"
}
# --- 1. Model Coefficient Processing ---
# Transpose coefficient matrix for downstream operations
coefs_before_sum <- t(as.matrix(coefs))  # coefs: Original regression coefficients
# --- 2. Cumulative Lag Effects Calculation ---
# Sum coefficients for each polynomial term (temp_d1 to temp_d4), excluding precipitation terms
poly_groups <- c("temp_d1", "temp_d2", "temp_d3", "temp_d4")
coefs_sum <- sapply(poly_groups, function(poly) {
# Identify columns matching the polynomial group (e.g., temp_d1_lag1, temp_d1_lag2)
poly_names = colnames(coefs_before_sum)[grepl(poly, colnames(coefs_before_sum)) & !grepl("prec", colnames(coefs_before_sum))]
rowSums(coefs_before_sum[, poly_names, drop = FALSE])  # Sum across lags
})
coefs_sum <- t(as.matrix(coefs_sum))  # Transpose back to original orientation
# --- 3. Temperature Response Curve ---
# Predict mortality response using polynomial-transformed temperatures
pred_vector <- pred_temps_poly %*% t(coefs_sum)  # pred_temps_poly: Temp values transformed via polynomial basis
# --- 4. Temperature Range Trimming ---
# Restrict predictions to 1%-99% percentile of observed temperatures to exclude extremes
observed_temps <- daily_temp$temp1  # Observed temperature data
t1_index <- collapse::fquantile(observed_temps, 0.01, na.rm = TRUE)  # 1st percentile
t99_index <- collapse::fquantile(observed_temps, 0.998, na.rm = TRUE)  # 99th percentile
mmt_options <- which(pred_temp_range > t1_index & pred_temp_range < t99_index)  # Indices within range
new_temp_range <- pred_temp_range[mmt_options]  # Subset temperature range
# --- 5. Minimum Mortality Temperature (MMT) ---
# Find temperature with lowest predicted mortality (MMT)
mmt <- new_temp_range[which.min(pred_vector[mmt_options])]
mmt_matrix <- poly(mmt, degree = 4, raw = T)  # Create polynomial terms for MMT
pred_temps_scaled <- scale(pred_temps_poly, center = mmt_matrix, scale = FALSE)  # Center temps at MMT
pred_vector <- pred_temps_scaled %*% t(coefs_sum)
# --- 6. Bootstrap Coefficient Processing ---
# Extract temperature-related coefficients from bootstrap results
temp_cols <- names(bstrap)[grep("temp", names(bstrap))]  # Columns with "temp" in name
bst_coefs_before_sum <- bstrap[, ..temp_cols]  # Subset bootstrap coefficients
bst_coefs_before_sum <- as.matrix(bst_coefs_before_sum)  # Convert to matrix
# --- 7. Bootstrap Response Calculation ---
# Sum bootstrap coefficients by polynomial group (same as step 2 but for bootstrapped coefs)
bst_coefs_sum <- sapply(poly_groups, function(poly) {
poly_names = colnames(bst_coefs_before_sum)[grepl(poly, colnames(bst_coefs_before_sum)) & !grepl("prec", colnames(bst_coefs_before_sum))]
rowSums(bst_coefs_before_sum[, poly_names, drop = FALSE])
})
# Predict mortality response for each bootstrap iteration
bstrap_result <- pred_temps_scaled %*% t(bst_coefs_sum)  # Rows: temps, cols: bootstrap samples
# Calculate response statistics (2.5%, median, 97.5%, mean)
response_stats <- cbind(
matrixStats::rowQuantiles(bstrap_result, probs = c(0.025, 0.5, 0.975), na.rm = TRUE),
mean = matrixStats::rowMeans2(bstrap_result, na.rm = TRUE)
)
# --- 8. Response Result ---
response <- data.table(
pred_q025 = response_stats[, 1],  # 2.5% quantile
pred = response_stats[, 4],       # Mean response
pred_q975 = response_stats[, 3],  # 97.5% quantile
bins = pred_temp_range            # Temperature bins
)[, `:=` (
key = "pooled",                   # Identifier for pooled analysis
model = model_name,               # Population group (e.g., "Young")
t1 = t1_index,                    # 1st percentile temp
t99 = t99_index                   # 99th percentile temp
)]
# --- 9. Add annual average person days exposure
midpoints <- (pred_temp_range[-1] + pred_temp_range[-length(pred_temp_range)]) / 2
midpoints <- as.character(midpoints)
cols <- c("adm_id", "year", time_agg_var, pop_var)
pwd <- merge( mort[, ..cols], temp_bins, by = c("adm_id", "year", time_agg_var) )
setnames(pwd, pop_var, "pop")
annual_pwd_bins <- pwd[!is.na(pop)]
rm(pwd)
gc(full = TRUE)
annual_pwd_bins[, (midpoints) := .SD * pop, .SDcols = midpoints]
annual_pwd_bins <- annual_pwd_bins[, lapply(.SD, sum), .SDcols = midpoints, by = .(year)]
annual_pwd_bins <- melt(annual_pwd_bins, measure.vars = midpoints, variable.name = "bins", value.name = "pop_deg_days", na.rm = TRUE)
# get overall deaths and merge with annual pwd
annual_pwd_bins <- merge(annual_pwd_bins, mort[, .(total_deaths = sum(get(death_var), na.rm = TRUE)), by = .(year)], by = c("year"))
annual_pwd_bins[, bins := ceiling(as.numeric(as.character(bins)))]
# take average annual person-day exposure and merge with response
response <- merge(response, annual_pwd_bins[, .(pop_deg_days = mean(pop_deg_days)), by = .(bins)], by = "bins", all.x = T)
bstrap_result
bstrap_result
bstrap_result
annual_pwd_bins
bstrap_result
dim(bstrap_result)
as.numeric(rownames(bstrap_result))
annual_pwd_bins
as.numeric(midpoints)
ceiling(as.numeric(as.character(bins)))
ceiling(as.numeric(as.character(midpoints)))
pwd
data.table(
bins = -50:50,
bstrap_result
)
data.table(bstrap_result)
melt(data.table(bins = -50:50, bstrap_result), id.vars = "bins", variable.name = "iteration", value.name = "pred")
bstrap_long[annual_pwd_bins, on = "bins", allow.cartesian = TRUE]
bstrap_long <- melt(data.table(bins = -50:50, bstrap_result), id.vars = "bins", variable.name = "iteration", value.name = "pred")
bstrap_long[annual_pwd_bins, on = "bins", allow.cartesian = TRUE]
response_by_year_bins <- bstrap_long[annual_pwd_bins, on = "bins", allow.cartesian = TRUE][, pct_bins_deaths := pred * pop_deg_days / total_deaths]
response_by_year_bins[, .(mean_pct_bins_deaths = mean(pct_bins_deaths)), by = .(bins, iterations)]
response_by_year_bins
response_by_year_bins[, .(mean_pct_bins_deaths = mean(pct_bins_deaths)), by = .(bins, iteration)]
response_by_year_bins
response_by_year_bins <- response_by_year_bins[, .(mean_pct_bins_deaths = mean(pct_bins_deaths)), by = .(bins, iteration)]
response_by_year_bins
response_by_year_bins <- response_by_year_bins[, .(mean_pct_bins_deaths = mean(pct_bins_deaths)), by = .(bins)]
response_by_year_bins <- response_by_year_bins[, .(mean_pct_bins_deaths = mean(mean_pct_bins_deaths)), by = .(bins)]
response_by_year_bins
response_by_year_bins %>%
ggplot(aes(x = bins, y = mean_pct_bins_deaths)) +
geom_bar(stat = 'identity', position = 'stack', width = 1, alpha = 1) +
scale_y_continuous(
labels = scales::percent_format()
)
bstrap_long <- melt(data.table(bins = -50:50, bstrap_result), id.vars = "bins", variable.name = "iteration", value.name = "pred")
response_by_year_bins <- bstrap_long[annual_pwd_bins, on = "bins", allow.cartesian = TRUE][, pct_bins_deaths := pred * pop_deg_days / total_deaths]
response_by_year_bins <- response_by_year_bins[, .(mean_pct_bins_deaths = mean(pct_bins_deaths)), by = .(bins, iteration)]
response_by_year_bins <- response_by_year_bins[, .(mean_pct_bins_deaths = median(mean_pct_bins_deaths)), by = .(bins)]
response_by_year_bins %>%
ggplot(aes(x = bins, y = mean_pct_bins_deaths)) +
geom_bar(stat = 'identity', position = 'stack', width = 1, alpha = 1) +
scale_y_continuous(
labels = scales::percent_format()
)
bstrap_result
bstrap_long <- melt(data.table(bins = -50:50, bstrap_result), id.vars = "bins", variable.name = "iteration", value.name = "pred")
bstrap_long
bstrap_long
bstrap_long[bins != -50,annual_pwd_bins, on = "bins", allow.cartesian = TRUE][, pct_bins_deaths := pred * pop_deg_days / total_deaths]
pwd
pwd <- merge( mort[, ..cols], temp_bins, by = c("adm_id", "year", time_agg_var) )
pwd
# population and degree days bin exposures
pwd <- merge( mort[, ..cols], temp_bins, by = c("adm_id", "year", time_agg_var) )
pwd
pwd
pop_var
pwd[, lapply(.SD, weighted.mean, w = pop, na.rm = T), by = year, .SDcols = midpoints]
setnames(pwd, pop_var, "pop")
pwd[, lapply(.SD, weighted.mean, w = pop, na.rm = T), by = year, .SDcols = midpoints]
melt(pw_degree_days, measure.vars = midpoints, variable.name = "bins", value.name = "pw_deg_days", na.rm = TRUE)
pw_degree_days <- pwd[, lapply(.SD, weighted.mean, w = pop, na.rm = T), by = year, .SDcols = midpoints]
melt(pw_degree_days, measure.vars = midpoints, variable.name = "bins", value.name = "pw_deg_days", na.rm = TRUE)
response
# get overall deaths and merge with annual pwd
pw_degree_days <- merge(pw_degree_days, mort[, .(total_deaths = sum(get(death_var), na.rm = TRUE)), by = .(year)], by = c("year"))
pw_degree_days
pw_degree_days <- pwd[, lapply(.SD, weighted.mean, w = pop, na.rm = T), by = year, .SDcols = midpoints]
pw_degree_days <- melt(pw_degree_days, measure.vars = midpoints, variable.name = "bins", value.name = "pw_deg_days", na.rm = TRUE)
pw_degree_days
# get overall deaths and merge with annual pwd
pw_degree_days <- merge(pw_degree_days, mort[, .(total_deaths = sum(get(death_var), na.rm = TRUE)), by = .(year)], by = c("year"))
pw_degree_days[, bins := ceiling(as.numeric(as.character(bins)))]
pw_degree_days
bstrap_long <- melt(data.table(bins = -50:50, bstrap_result), id.vars = "bins", variable.name = "iteration", value.name = "pred")
response_by_year_bins <- bstrap_long[pw_degree_days, on = "bins", allow.cartesian = TRUE][, pct_bins_deaths := pred * pw_deg_days / total_deaths]
response_by_year_bins <- response_by_year_bins[, .(mean_pct_bins_deaths = mean(pct_bins_deaths)), by = .(bins, iteration)]
response_by_year_bins <- response_by_year_bins[, .(mean_pct_bins_deaths = median(mean_pct_bins_deaths)), by = .(bins)]
response_by_year_bins
response_by_year_bins %>%
ggplot(aes(x = bins, y = mean_pct_bins_deaths)) +
geom_bar(stat = 'identity', position = 'stack', width = 1, alpha = 1) +
scale_y_continuous(
labels = scales::percent_format()
)
response_by_year_bins %>%
ggplot(aes(x = bins, y = mean_pct_bins_deaths)) +
geom_bar(stat = 'identity', position = 'stack', width = 1, alpha = 1)
response_by_year_bins
# population and degree days bin exposures
pwd <- merge( mort[, ..cols], temp_bins, by = c("adm_id", "year", time_agg_var) )
setnames(pwd, pop_var, "pop")
pwd
temp_bins
# population and degree days bin exposures
pwd <- merge( mort[, ..cols], temp_bins, by = c("adm_id", "year", time_agg_var) )
setnames(pwd, pop_var, "pop")
# annual pop person day exposure
annual_pwd_bins <- pwd[!is.na(pop)]
rm(pwd)
gc(full = TRUE)
annual_pwd_bins[, (midpoints) := .SD * pop, .SDcols = midpoints]
annual_pwd_bins <- annual_pwd_bins[, lapply(.SD, sum), .SDcols = midpoints, by = .(year)]
annual_pwd_bins <- melt(annual_pwd_bins, measure.vars = midpoints, variable.name = "bins", value.name = "pop_deg_days", na.rm = TRUE)
annual_pwd_bins
# get overall deaths and merge with annual pwd
annual_pwd_bins <- merge(annual_pwd_bins, mort[, .(total_deaths = sum(get(death_var), na.rm = TRUE)), by = .(year)], by = c("year"))
annual_pwd_bins[, bins := ceiling(as.numeric(as.character(bins)))]
annual_pwd_bins
# percent of overall annual deaths in each bins
bstrap_long <- melt(data.table(bins = -50:50, bstrap_result), id.vars = "bins", variable.name = "iteration", value.name = "pred")
# percent of overall annual deaths in each bins
bstrap_long <- melt(data.table(bins = -50:50, bstrap_result), id.vars = "bins", variable.name = "iteration", value.name = "pred")
response_by_year_bins <- bstrap_long[annual_pwd_bins, on = "bins", allow.cartesian = TRUE][, pct_bins_deaths := pred * pop_deg_days / total_deaths]
response_by_year_bins <- response_by_year_bins[, .(mean_pct_bins_deaths = mean(pct_bins_deaths)), by = .(bins, iteration)] # collapse year
response_by_year_bins <- response_by_year_bins[, .(mean_pct_bins_deaths = median(mean_pct_bins_deaths)), by = .(bins)] # collapse iterations
response_by_year_bins
response_by_year_bins %>%
ggplot(aes(x = bins, y = mean_pct_bins_deaths)) +
geom_bar(stat = 'identity', position = 'stack', width = 1, alpha = 1) +
scale_y_continuous(
labels = scales::percent_format()
)
# Percent of overall annual deaths in each bin
bstrap_long <- melt(data.table(bins = -50:50, bstrap_result), id.vars = "bins", variable.name = "iteration", value.name = "pred")
response_by_year_bins <- bstrap_long[annual_pwd_bins, on = "bins", allow.cartesian = TRUE][, pct_bins_deaths := pred * pop_deg_days / total_deaths]
response_by_year_bins <- response_by_year_bins[, .(mean_pct_bins_deaths = mean(pct_bins_deaths)), by = .(bins)] # collapse year and iteration
rm(annual_pwd_bins)
gc(full = TRUE)
rm(annual_pwd_bins)
response_by_year_bins %>%
ggplot(aes(x = bins, y = mean_pct_bins_deaths)) +
geom_bar(stat = 'identity', position = 'stack', width = 1, alpha = 1) +
scale_y_continuous(
labels = scales::percent_format()
)
response_by_year_bins
response_by_year_bins[, `:=` (key = "pooled", model = model_name, t1 = t1_index, t99 = t99_index)]
response_by_year_bins
bstrap_long
# --- 10. Percent of overall annual deaths in each bin
bstrap_long <- melt(data.table(bins = -50:50, bstrap_result), id.vars = "bins", variable.name = "iteration", value.name = "pred")
response_by_year_bins <- bstrap_long[annual_pwd_bins, on = "bins", allow.cartesian = TRUE][, bins_deaths := pred * pop_deg_days]
# Population and degree days bin exposures
pwd <- merge(mort[, ..cols], temp_bins, by = c("adm_id", "year", time_agg_var))
setnames(pwd, pop_var, "pop")
# Annual population person-day exposure
annual_pwd_bins <- pwd[!is.na(pop)]
rm(pwd)
gc(full = TRUE)
annual_pwd_bins[, (midpoints) := .SD * pop, .SDcols = midpoints]
annual_pwd_bins <- annual_pwd_bins[, lapply(.SD, sum), .SDcols = midpoints, by = .(year)]
annual_pwd_bins <- melt(annual_pwd_bins, measure.vars = midpoints, variable.name = "bins", value.name = "pop_deg_days", na.rm = TRUE)
# Get overall deaths and merge with annual person-day exposure
annual_pwd_bins <- merge(annual_pwd_bins, mort[, .(total_deaths = sum(get(death_var), na.rm = TRUE)), by = .(year)], by = "year")
annual_pwd_bins[, bins := ceiling(as.numeric(as.character(bins)))]
# Take average annual person-day exposure and merge with response
response <- merge(response, annual_pwd_bins[, .(pop_deg_days = mean(pop_deg_days)), by = .(bins)], by = "bins", all.x = TRUE)
# --- 10. Percent of overall annual deaths in each bin
bstrap_long <- melt(data.table(bins = -50:50, bstrap_result), id.vars = "bins", variable.name = "iteration", value.name = "pred")
response_by_year_bins <- bstrap_long[annual_pwd_bins, on = "bins", allow.cartesian = TRUE][, bins_deaths := pred * pop_deg_days]
response_by_year_bins
response_by_year_bins
response_by_year_bins <- response_by_year_bins[, .(bins_deaths = mean(pct_bins_deaths), total_deaths = mean(total_deaths)), by = .(bins)] # collapse year and iteration
response_by_year_bins <- response_by_year_bins[, .(bins_deaths = mean(bins_deaths), total_deaths = mean(total_deaths)), by = .(bins)] # collapse year and iteration
response_by_year_bins[, `:=` (key = "pooled", model = model_name, t1 = t1_index, t99 = t99_index)]
response_by_year_bins
response_by_year_bins %>%
ggplot(aes(x = bins, y = bins_deaths / total_deaths)) +
geom_bar(stat = 'identity', position = 'stack', width = 1, alpha = 1) +
scale_y_continuous(
labels = scales::percent_format()
)
